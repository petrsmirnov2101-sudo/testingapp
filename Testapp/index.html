<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–¢–µ—Å—Ç–æ–≤–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <style>
        .drag-over { background-color: #dbeafe !important; border-color: #3b82f6 !important; }
        .dragging { opacity: 0.5; }
        .matched { background-color: #dcfce7 !important; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div id="app" class="max-w-4xl mx-auto p-4">
        <!-- Navigation -->
        <nav class="bg-white rounded-lg shadow-md p-4 mb-6">
            <div class="flex flex-wrap gap-2 justify-center">
                <button onclick="showTab('parser')" class="tab-btn px-4 py-2 rounded-lg bg-blue-500 text-white hover:bg-blue-600 transition" data-tab="parser">üìÑ –ü–∞—Ä—Å–µ—Ä</button>
                <button onclick="showTab('questions')" class="tab-btn px-4 py-2 rounded-lg bg-gray-200 hover:bg-gray-300 transition" data-tab="questions">üìã –í–æ–ø—Ä–æ—Å—ã</button>
                <button onclick="showTab('test')" class="tab-btn px-4 py-2 rounded-lg bg-gray-200 hover:bg-gray-300 transition" data-tab="test">‚úèÔ∏è –¢–µ—Å—Ç</button>
                <button onclick="showTab('errors')" class="tab-btn px-4 py-2 rounded-lg bg-gray-200 hover:bg-gray-300 transition" data-tab="errors">‚ùå –û—à–∏–±–∫–∏</button>
            </div>
        </nav>

        <!-- Parser Tab -->
        <div id="parser-tab" class="tab-content">
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-2xl font-bold mb-4 text-center">–ó–∞–≥—Ä—É–∑–∫–∞ DOCX —Ñ–∞–π–ª–∞</h2>
                <div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-400 transition cursor-pointer" onclick="document.getElementById('fileInput').click()">
                    <input type="file" id="fileInput" accept=".docx" class="hidden" onchange="handleFileUpload(event)">
                    <div class="text-6xl mb-4">üìÅ</div>
                    <p class="text-gray-600">–ù–∞–∂–º–∏—Ç–µ –∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ DOCX —Ñ–∞–π–ª</p>
                </div>
                <div id="parseStatus" class="mt-4 text-center hidden"></div>
                <div id="parsePreview" class="mt-4 hidden">
                    <h3 class="font-bold mb-2">–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤:</h3>
                    <div id="previewContent" class="max-h-96 overflow-y-auto border rounded p-4 bg-gray-50"></div>
                    <button onclick="saveQuestions()" class="mt-4 w-full bg-green-500 text-white py-3 rounded-lg hover:bg-green-600 transition font-bold">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–æ–ø—Ä–æ—Å—ã</button>
                </div>
                
                <!-- Debug area -->
                <div id="debugArea" class="mt-4 hidden">
                    <h3 class="font-bold mb-2">Debug –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</h3>
                    <pre id="debugContent" class="text-xs bg-gray-800 text-green-400 p-4 rounded overflow-auto max-h-60"></pre>
                    <button onclick="showRawHtml()" class="mt-2 bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700">–ü–æ–∫–∞–∑–∞—Ç—å —Å—ã—Ä–æ–π HTML</button>
                </div>
                
                <!-- Manual add -->
                <div class="bg-white rounded-lg shadow-md p-6 mt-6">
                    <h2 class="text-2xl font-bold mb-4 text-center">–†—É—á–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤–æ–ø—Ä–æ—Å–∞</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="block mb-1 font-medium">–¢–∏–ø –≤–æ–ø—Ä–æ—Å–∞:</label>
                            <select id="manualType" class="w-full border rounded p-2" onchange="toggleManualFields()">
                                <option value="simple">–ü—Ä–æ—Å—Ç–æ–π</option>
                                <option value="matching">–ù–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ</option>
                                <option value="free">–°–≤–æ–±–æ–¥–Ω—ã–π –æ—Ç–≤–µ—Ç</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block mb-1 font-medium">–í–æ–ø—Ä–æ—Å:</label>
                            <textarea id="manualQuestion" class="w-full border rounded p-2 h-20" placeholder="–¢–µ–∫—Å—Ç –≤–æ–ø—Ä–æ—Å–∞..."></textarea>
                        </div>
                        
                        <!-- Simple question options -->
                        <div id="simpleFields">
                            <label class="block mb-1 font-medium">–í–∞—Ä–∏–∞–Ω—Ç—ã (–∫–∞–∂–¥—ã–π —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏, —Ñ–æ—Ä–º–∞—Ç: –ê) —Ç–µ–∫—Å—Ç):</label>
                            <textarea id="manualOptions" class="w-full border rounded p-2 h-32" placeholder="1) –ü–µ—Ä–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç&#10;2) –í—Ç–æ—Ä–æ–π –≤–∞—Ä–∏–∞–Ω—Ç&#10;3) –¢—Ä–µ—Ç–∏–π –≤–∞—Ä–∏–∞–Ω—Ç"></textarea>
                            <label class="block mb-1 mt-2 font-medium">–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç (1, 2, 3 –∏–ª–∏ –ê, –ë, –í):</label>
                            <input id="manualAnswer" class="w-full border rounded p-2" placeholder="1">
                        </div>
                        
                        <!-- Matching question options -->
                        <div id="matchingFields" class="hidden">
                            <label class="block mb-1 font-medium">–õ–µ–≤–∞—è —á–∞—Å—Ç—å (—Ü–∏—Ñ—Ä—ã, –∫–∞–∂–¥—ã–π —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏):</label>
                            <textarea id="manualLeft" class="w-full border rounded p-2 h-24" placeholder="1) –ü–µ—Ä–≤—ã–π –ø—É–Ω–∫—Ç&#10;2) –í—Ç–æ—Ä–æ–π –ø—É–Ω–∫—Ç&#10;3) –¢—Ä–µ—Ç–∏–π –ø—É–Ω–∫—Ç"></textarea>
                            <label class="block mb-1 mt-2 font-medium">–ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å (–±—É–∫–≤—ã, –∫–∞–∂–¥—ã–π —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏):</label>
                            <textarea id="manualRight" class="w-full border rounded p-2 h-24" placeholder="–ê) –ü–µ—Ä–≤–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ&#10;–ë) –í—Ç–æ—Ä–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ&#10;–í) –¢—Ä–µ—Ç—å–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ"></textarea>
                            <label class="block mb-1 mt-2 font-medium">–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è (—Ñ–æ—Ä–º–∞—Ç: 1-–ê, 2-–ë, 3-–í):</label>
                            <input id="manualMatching" class="w-full border rounded p-2" placeholder="1-–ê, 2-–ë, 3-–í">
                        </div>
                        
                        <!-- Free question -->
                        <div id="freeFields" class="hidden">
                            <label class="block mb-1 font-medium">–≠—Ç–∞–ª–æ–Ω –æ—Ç–≤–µ—Ç–∞:</label>
                            <textarea id="manualFreeAnswer" class="w-full border rounded p-2 h-20" placeholder="–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç..."></textarea>
                        </div>
                        
                        <button onclick="addManualQuestion()" class="w-full bg-green-500 text-white py-3 rounded-lg hover:bg-green-600 transition font-bold">‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤–æ–ø—Ä–æ—Å</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Questions Tab -->
        <div id="questions-tab" class="tab-content hidden">
            <div class="bg-white rounded-lg shadow-md p-6">
                <div class="flex flex-wrap justify-between items-center mb-4 gap-2">
                    <h2 class="text-2xl font-bold">–ë–∞–∑–∞ –≤–æ–ø—Ä–æ—Å–æ–≤</h2>
                    <div class="flex gap-2">
                        <span id="questionCount" class="bg-blue-100 text-blue-800 px-3 py-1 rounded-full"></span>
                        <button onclick="clearAllQuestions()" class="bg-red-500 text-white px-4 py-1 rounded-lg hover:bg-red-600 transition text-sm">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë</button>
                    </div>
                </div>
                <div id="questionsList" class="space-y-4 max-h-[60vh] overflow-y-auto"></div>
            </div>
        </div>

        <!-- Test Tab -->
        <div id="test-tab" class="tab-content hidden">
            <div class="bg-white rounded-lg shadow-md p-6">
                <div id="testSetup">
                    <h2 class="text-2xl font-bold mb-4 text-center">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–µ—Å—Ç–∞</h2>
                    <div class="space-y-4">
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="randomize" checked class="w-5 h-5">
                            <span>–ü–µ—Ä–µ–º–µ—à–∞—Ç—å –≤–æ–ø—Ä–æ—Å—ã</span>
                        </label>
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="randomizeAnswers" checked class="w-5 h-5">
                            <span>–ü–µ—Ä–µ–º–µ—à–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤</span>
                        </label>
                        <div>
                            <label class="block mb-2">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–ø—Ä–æ—Å–æ–≤:</label>
                            <input type="number" id="questionLimit" min="1" class="w-full border rounded p-2" placeholder="–í—Å–µ –≤–æ–ø—Ä–æ—Å—ã">
                        </div>
                        <div>
                            <label class="block mb-2">–§–∏–ª—å—Ç—Ä –ø–æ —Ç–∏–ø—É:</label>
                            <select id="typeFilter" class="w-full border rounded p-2">
                                <option value="all">–í—Å–µ —Ç–∏–ø—ã</option>
                                <option value="simple">–ü—Ä–æ—Å—Ç—ã–µ</option>
                                <option value="matching">–ù–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ</option>
                                <option value="free">–°–≤–æ–±–æ–¥–Ω—ã–π –æ—Ç–≤–µ—Ç</option>
                            </select>
                        </div>
                        <button onclick="startTest()" class="w-full bg-blue-500 text-white py-3 rounded-lg hover:bg-blue-600 transition font-bold text-lg">‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å —Ç–µ—Å—Ç</button>
                    </div>
                </div>
                <div id="testArea" class="hidden">
                    <div class="flex justify-between items-center mb-4">
                        <span id="testProgress" class="font-bold"></span>
                        <button onclick="endTest()" class="text-red-500 hover:text-red-700">‚úñÔ∏è –ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
                    </div>
                    <div id="questionArea" class="mb-6"></div>
                    <div class="flex gap-2">
                        <button onclick="prevQuestion()" id="prevBtn" class="flex-1 bg-gray-200 py-3 rounded-lg hover:bg-gray-300 transition">‚¨ÖÔ∏è –ù–∞–∑–∞–¥</button>
                        <button onclick="checkAnswer()" id="checkBtn" class="flex-1 bg-yellow-500 text-white py-3 rounded-lg hover:bg-yellow-600 transition">‚úîÔ∏è –ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
                        <button onclick="nextQuestion()" id="nextBtn" class="flex-1 bg-blue-500 text-white py-3 rounded-lg hover:bg-blue-600 transition">–î–∞–ª–µ–µ ‚û°Ô∏è</button>
                    </div>
                </div>
                <div id="testResults" class="hidden text-center">
                    <h2 class="text-2xl font-bold mb-4">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã</h2>
                    <div id="resultsContent"></div>
                    <button onclick="showTab('test'); document.getElementById('testResults').classList.add('hidden'); document.getElementById('testSetup').classList.remove('hidden');" class="mt-4 bg-blue-500 text-white px-6 py-3 rounded-lg hover:bg-blue-600 transition">üîÑ –ù–æ–≤—ã–π —Ç–µ—Å—Ç</button>
                </div>
            </div>
        </div>

        <!-- Errors Tab -->
        <div id="errors-tab" class="tab-content hidden">
            <div class="bg-white rounded-lg shadow-md p-6">
                <div class="flex flex-wrap justify-between items-center mb-4 gap-2">
                    <h2 class="text-2xl font-bold">–û—à–∏–±–æ—á–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã</h2>
                    <div class="flex gap-2">
                        <span id="errorCount" class="bg-red-100 text-red-800 px-3 py-1 rounded-full"></span>
                        <button onclick="clearErrors()" class="bg-gray-500 text-white px-4 py-1 rounded-lg hover:bg-gray-600 transition text-sm">üßπ –û—á–∏—Å—Ç–∏—Ç—å</button>
                        <button onclick="practiceErrors()" class="bg-orange-500 text-white px-4 py-1 rounded-lg hover:bg-orange-600 transition text-sm">üìù –†–µ—à–∞—Ç—å</button>
                    </div>
                </div>
                <div id="errorsList" class="space-y-4 max-h-[60vh] overflow-y-auto"></div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let questions = JSON.parse(localStorage.getItem('testQuestions') || '[]');
        let errors = JSON.parse(localStorage.getItem('testErrors') || '[]');
        let parsedQuestions = [];
        let currentTest = [];
        let currentIndex = 0;
        let testAnswers = {};
        let testMode = 'normal';
        let debugLog = [];

        function log(msg, data = null) {
            const entry = data ? `${msg}: ${JSON.stringify(data, null, 2)}` : msg;
            debugLog.push(entry);
            console.log(msg, data || '');
        }

        // Tab navigation
        function showTab(tab) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.tab-btn').forEach(el => {
                el.classList.remove('bg-blue-500', 'text-white');
                el.classList.add('bg-gray-200');
            });
            document.getElementById(`${tab}-tab`).classList.remove('hidden');
            document.querySelector(`[data-tab="${tab}"]`).classList.remove('bg-gray-200');
            document.querySelector(`[data-tab="${tab}"]`).classList.add('bg-blue-500', 'text-white');
            
            if (tab === 'questions') renderQuestionsList();
            if (tab === 'errors') renderErrorsList();
        }

        // ==================== –ü–ê–†–°–ï–† ====================
        
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const status = document.getElementById('parseStatus');
            status.classList.remove('hidden');
            status.innerHTML = '<span class="text-blue-500">‚è≥ –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞...</span>';
            debugLog = [];

            try {
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.convertToHtml({ arrayBuffer });
                log('HTML –ø–æ–ª—É—á–µ–Ω, –¥–ª–∏–Ω–∞', result.value.length);
                parseDocxContent(result.value);
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º debug
                document.getElementById('debugArea').classList.remove('hidden');
                document.getElementById('debugContent').textContent = debugLog.join('\n');
            } catch (error) {
                status.innerHTML = `<span class="text-red-500">‚ùå –û—à–∏–±–∫–∞: ${error.message}</span>`;
            }
        }

        function parseDocxContent(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const tables = doc.querySelectorAll('table');
            parsedQuestions = [];

            log('–ù–∞–π–¥–µ–Ω–æ —Ç–∞–±–ª–∏—Ü', tables.length);

            tables.forEach((table, tableIndex) => {
                const rows = table.querySelectorAll('tr');
                log(`–¢–∞–±–ª–∏—Ü–∞ ${tableIndex + 1}: —Å—Ç—Ä–æ–∫`, rows.length);
                
                let skipNextRow = false;
                
                for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                    if (skipNextRow) {
                        skipNextRow = false;
                        log(`  –°—Ç—Ä–æ–∫–∞ ${rowIndex + 1}: –ø—Ä–æ–ø—É—â–µ–Ω–∞ (—á–∞—Å—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –≤–æ–ø—Ä–æ—Å–∞)`);
                        continue;
                    }
                    
                    const row = rows[rowIndex];
                    const cells = row.querySelectorAll('td, th');
                    if (cells.length >= 2) {
                        const cellTexts = Array.from(cells).map(c => c.innerText.substring(0, 80));
                        log(`  –°—Ç—Ä–æ–∫–∞ ${rowIndex + 1} (${cells.length} —è—á–µ–µ–∫)`, cellTexts);
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π –≤–æ–ø—Ä–æ—Å —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è
                        const cellData = Array.from(cells).map(c => ({
                            html: c.innerHTML.trim(),
                            text: getCellText(c)
                        }));
                        
                        const hasMatchKeyword = cellData.some(c => 
                            c.text.toLowerCase().includes('—Å–æ–æ—Ç–Ω–µ—Å–∏—Ç–µ') || 
                            c.text.toLowerCase().includes('—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ') ||
                            c.text.toLowerCase().includes('—Å–æ–ø–æ—Å—Ç–∞–≤—å—Ç–µ')
                        );
                        
                        // –ï—Å–ª–∏ —ç—Ç–æ –≤–æ–ø—Ä–æ—Å –Ω–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∏ –µ—Å—Ç—å —Å–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä–æ–∫–∞
                        if (hasMatchKeyword && rowIndex + 1 < rows.length) {
                            const nextRow = rows[rowIndex + 1];
                            const nextCells = nextRow.querySelectorAll('td, th');
                            const nextCellData = Array.from(nextCells).map(c => ({
                                html: c.innerHTML.trim(),
                                text: getCellText(c)
                            }));
                            
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä–æ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã (–ê) –ë) –∏–ª–∏ 1) 2))
                            const nextRowText = nextCellData.map(c => c.text).join(' ');
                            const hasOptions = /[–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEF]\s*\)/.test(nextRowText) || /\d\s*\)/.test(nextRowText);
                            
                            if (hasOptions) {
                                log(`  –°—Ç—Ä–æ–∫–∞ ${rowIndex + 2} —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã, –æ–±—ä–µ–¥–∏–Ω—è–µ–º`);
                                const question = parseMultiRowMatching(cellData, nextCellData);
                                if (question) {
                                    log(`  ‚úì –†–∞—Å–ø–æ–∑–Ω–∞–Ω: ${question.type} (–º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π)`);
                                    parsedQuestions.push(question);
                                    skipNextRow = true;
                                    continue;
                                }
                            }
                        }
                        
                        const question = parseTableRow(cells);
                        if (question) {
                            log(`  ‚úì –†–∞—Å–ø–æ–∑–Ω–∞–Ω: ${question.type}`);
                            parsedQuestions.push(question);
                        } else {
                            log(`  ‚úó –ù–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ`);
                        }
                    }
                }
            });

            displayParsePreview();
        }

        // –£—Ç–∏–ª–∏—Ç–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –∏–∑ —è—á–µ–π–∫–∏
        function getCellText(cell) {
            return cell.innerHTML
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<\/p>\s*<p[^>]*>/gi, '\n')
                .replace(/<[^>]+>/g, '')
                .trim();
        }
        
        // –ü–∞—Ä—Å–∏–Ω–≥ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞ –Ω–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ (–≤–æ–ø—Ä–æ—Å –≤ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ, –≤–∞—Ä–∏–∞–Ω—Ç—ã –≤ —Å–ª–µ–¥—É—é—â–µ–π)
        function parseMultiRowMatching(questionRowData, optionsRowData) {
            log(`    –ü–∞—Ä—Å–∏–Ω–≥ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω–æ–≥–æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è`);
            
            // –°—Ç—Ä–æ–∫–∞ 1: –Ω–æ–º–µ—Ä | –≤–æ–ø—Ä–æ—Å "–°–æ–æ—Ç–Ω–µ—Å–∏—Ç–µ..." | –æ—Ç–≤–µ—Ç "1)–ê 2)–ë"
            // –°—Ç—Ä–æ–∫–∞ 2: –ê) —Ç–µ–∫—Å—Ç –ë) —Ç–µ–∫—Å—Ç | 1) —Ç–µ–∫—Å—Ç 2) —Ç–µ–∫—Å—Ç
            
            // –ù–∞—Ö–æ–¥–∏–º –≤–æ–ø—Ä–æ—Å (—è—á–µ–π–∫–∞ —Å "–°–æ–æ—Ç–Ω–µ—Å–∏—Ç–µ")
            let questionText = '';
            let answerText = '';
            
            for (const cell of questionRowData) {
                if (cell.text.toLowerCase().includes('—Å–æ–æ—Ç–Ω–µ—Å–∏—Ç–µ') || 
                    cell.text.toLowerCase().includes('—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ') ||
                    cell.text.toLowerCase().includes('—Å–æ–ø–æ—Å—Ç–∞–≤—å—Ç–µ')) {
                    questionText = cell.text.trim();
                }
                // –ò—â–µ–º –æ—Ç–≤–µ—Ç (—Å–æ–¥–µ—Ä–∂–∏—Ç 1)–ê –∏–ª–∏ 1-–ê)
                if (/\d\s*\)\s*[–ê-–Ø–∞-—èA-Za-z]/.test(cell.text) || /\d\s*-\s*[–ê-–Ø–∞-—èA-Za-z]/.test(cell.text)) {
                    answerText = cell.text.trim();
                }
            }
            
            log(`    –í–æ–ø—Ä–æ—Å: "${questionText.substring(0, 50)}..."`);
            log(`    –û—Ç–≤–µ—Ç: "${answerText}"`);
            
            // –ü–∞—Ä—Å–∏–º –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏–∑ –≤—Ç–æ—Ä–æ–π —Å—Ç—Ä–æ–∫–∏
            const leftItems = [];  // –ê), –ë), –í)
            const rightItems = []; // 1), 2), 3)
            
            const letterPattern = /^([–ê-–ØA-Z])\)\s*(.+)$/i;
            const numberPattern = /^(\d+)\)\s*(.+)$/;
            
            for (const cell of optionsRowData) {
                const lines = cell.text.split('\n');
                for (let line of lines) {
                    line = line.trim();
                    if (!line) continue;
                    
                    const leftMatch = line.match(letterPattern);
                    if (leftMatch) {
                        let key = leftMatch[1].toUpperCase();
                        const keyMap = {'A': '–ê', 'B': '–ë', 'C': '–í', 'D': '–ì', 'E': '–î', 'F': '–ï'};
                        key = keyMap[key] || key;
                        leftItems.push({ key, text: leftMatch[2].trim() });
                        log(`    –õ–µ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç: ${key}) ${leftMatch[2].trim().substring(0, 30)}`);
                        continue;
                    }
                    
                    const rightMatch = line.match(numberPattern);
                    if (rightMatch) {
                        rightItems.push({ key: rightMatch[1], text: rightMatch[2].trim() });
                        log(`    –ü—Ä–∞–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç: ${rightMatch[1]}) ${rightMatch[2].trim().substring(0, 30)}`);
                    }
                }
            }
            
            log(`    –ù–∞–π–¥–µ–Ω–æ: –ª–µ–≤—ã—Ö=${leftItems.length}, –ø—Ä–∞–≤—ã—Ö=${rightItems.length}`);
            
            if (leftItems.length === 0 || rightItems.length === 0) {
                log(`    ‚ö† –ù–µ –Ω–∞–π–¥–µ–Ω—ã –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è`);
                return null;
            }
            
            // –ü–∞—Ä—Å–∏–º –æ—Ç–≤–µ—Ç
            const answerMap = parseMatchingAnswer(answerText);
            
            if (Object.keys(answerMap).length === 0) {
                log(`    ‚ö† –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –æ—Ç–≤–µ—Ç`);
                return null;
            }
            
            return {
                id: Date.now() + Math.random(),
                type: 'matching',
                question: questionText || '–°–æ–æ—Ç–Ω–µ—Å–∏—Ç–µ —ç–ª–µ–º–µ–Ω—Ç—ã:',
                leftItems,
                rightItems,
                correctAnswer: answerMap,
                raw: questionRowData.map(c => c.text).join(' | ') + ' || ' + optionsRowData.map(c => c.text).join(' | ')
            };
        }

        // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã
        function parseTableRow(cells) {
            const cellCount = cells.length;
            const cellData = Array.from(cells).map(c => ({
                html: c.innerHTML.trim(),
                text: getCellText(c)
            }));

            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
            if (cellData.every(c => !c.text || c.text.length < 2)) return null;
            
            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏
            const firstCellLower = cellData[0].text.toLowerCase();
            if (firstCellLower.includes('‚Ññ') || firstCellLower.includes('–Ω–æ–º–µ—Ä') || 
                firstCellLower === 'n' || firstCellLower.includes('–≤–æ–ø—Ä–æ—Å')) return null;

            log(`    –ê–Ω–∞–ª–∏–∑ ${cellCount} —Å—Ç–æ–ª–±—Ü–æ–≤`);
            
            // –õ–æ–≥–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —è—á–µ–µ–∫ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            cellData.forEach((c, i) => {
                log(`    –Ø—á–µ–π–∫–∞ ${i + 1}: "${c.text.substring(0, 60).replace(/\n/g, '‚Üµ')}..."`);
            });

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø–æ –∫–ª—é—á–µ–≤–æ–º—É —Å–ª–æ–≤—É
            const hasMatchKeyword = cellData.some(c => 
                c.text.toLowerCase().includes('—Å–æ–æ—Ç–Ω–µ—Å–∏—Ç–µ') || 
                c.text.toLowerCase().includes('—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ') ||
                c.text.toLowerCase().includes('—Å–æ–ø–æ—Å—Ç–∞–≤—å—Ç–µ')
            );
            
            if (hasMatchKeyword) {
                log(`    –ù–∞–π–¥–µ–Ω–æ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è`);
                return parseMatchingByKeyword(cellData);
            }

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —Å—Ç–æ–ª–±—Ü–æ–≤
            if (cellCount >= 5) {
                return parseRow5Columns(cellData);
            } else if (cellCount === 4) {
                return parseRow4Columns(cellData);
            } else if (cellCount === 3) {
                return parseRow3Columns(cellData);
            } else if (cellCount === 2) {
                return parseRow2Columns(cellData);
            }

            return null;
        }
        
        // –ü–∞—Ä—Å–∏–Ω–≥ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è - –∞–¥–∞–ø—Ç–∞—Ü–∏—è Python –ª–æ–≥–∏–∫–∏
        function parseMatchingByKeyword(cellData) {
            // –õ–æ–≥–∏–∫–∞ –∏–∑ Python: —Å–æ–±–∏—Ä–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ –≤—Å–µ—Ö —è—á–µ–µ–∫ –∫—Ä–æ–º–µ –ø–µ—Ä–≤–æ–π (–Ω–æ–º–µ—Ä) –∏ –ø–æ—Å–ª–µ–¥–Ω–µ–π (–æ—Ç–≤–µ—Ç)
            // –ü–æ—Å–ª–µ–¥–Ω—è—è —è—á–µ–π–∫–∞ - –æ—Ç–≤–µ—Ç
            
            if (cellData.length < 3) {
                log(`    –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —è—á–µ–µ–∫ –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è: ${cellData.length}`);
                return null;
            }
            
            // –°–æ–±–∏—Ä–∞–µ–º –≤–µ—Å—å —Ç–µ–∫—Å—Ç –∏–∑ —è—á–µ–µ–∫ (–∫—Ä–æ–º–µ –ø–µ—Ä–≤–æ–π –∏ –ø–æ—Å–ª–µ–¥–Ω–µ–π)
            let allText = '';
            for (let i = 1; i < cellData.length - 1; i++) {
                allText += '\n' + cellData[i].text;
            }
            
            // –ü–æ—Å–ª–µ–¥–Ω—è—è —è—á–µ–π–∫–∞ - –æ—Ç–≤–µ—Ç
            const correctAnswerText = cellData[cellData.length - 1].text.trim();
            
            log(`    –í–µ—Å—å —Ç–µ–∫—Å—Ç: "${allText.substring(0, 200).replace(/\n/g, '‚Üµ')}..."`);
            log(`    –û—Ç–≤–µ—Ç: "${correctAnswerText}"`);
            
            if (!allText.trim()) return null;
            
            // –†–∞–∑–±–∏—Ä–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
            const lines = allText.split('\n');
            let mainQuestion = '';
            const leftItems = [];  // –ê), –ë), –í) - –±—É–∫–≤—ã
            const rightItems = []; // 1), 2), 3) - —Ü–∏—Ñ—Ä—ã
            
            const letterPattern = /^([–ê-–ØA-Z])\)\s*(.+)$/i;
            const numberPattern = /^(\d+)\)\s*(.+)$/;
            
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
                if (line.toLowerCase() === '—Å–æ–æ—Ç–Ω–µ—Å–∏—Ç–µ:' || line.toLowerCase() === '—Å –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏:') {
                    continue;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–µ–≤—É—é –∫–æ–ª–æ–Ω–∫—É (–ê), –ë), –í)...)
                const leftMatch = line.match(letterPattern);
                if (leftMatch) {
                    let key = leftMatch[1].toUpperCase();
                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã –≤ –∫–∏—Ä–∏–ª–ª–∏—á–µ—Å–∫–∏–µ
                    const keyMap = {'A': '–ê', 'B': '–ë', 'C': '–í', 'D': '–ì', 'E': '–î', 'F': '–ï'};
                    key = keyMap[key] || key;
                    leftItems.push({ key, text: leftMatch[2].trim() });
                    log(`    –ù–∞–π–¥–µ–Ω –ª–µ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç: ${key}) ${leftMatch[2].trim().substring(0, 30)}`);
                    continue;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤—É—é –∫–æ–ª–æ–Ω–∫—É (1), 2), 3)...)
                const rightMatch = line.match(numberPattern);
                if (rightMatch) {
                    rightItems.push({ key: rightMatch[1], text: rightMatch[2].trim() });
                    log(`    –ù–∞–π–¥–µ–Ω –ø—Ä–∞–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç: ${rightMatch[1]}) ${rightMatch[2].trim().substring(0, 30)}`);
                    continue;
                }
                
                // –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —ç–ª–µ–º–µ–Ω—Ç —Å–ø–∏—Å–∫–∞, —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–æ–ø—Ä–æ—Å
                if (leftItems.length === 0 && rightItems.length === 0 && !line.toLowerCase().startsWith('—Å–æ–æ—Ç–Ω–µ—Å')) {
                    mainQuestion += ' ' + line;
                } else if (line.toLowerCase().includes('—Å–æ–æ—Ç–Ω–µ—Å–∏—Ç–µ') || line.toLowerCase().includes('—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ')) {
                    mainQuestion = line;
                }
            }
            
            mainQuestion = mainQuestion.trim();
            
            // –ï—Å–ª–∏ –æ—Å–Ω–æ–≤–Ω–æ–π –≤–æ–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—â–µ–º —Å—Ç—Ä–æ–∫—É —Å "—Å–æ–æ—Ç–Ω–µ—Å–∏—Ç–µ"
            if (!mainQuestion) {
                for (let line of lines) {
                    if (line.toLowerCase().includes('—Å–æ–æ—Ç–Ω–µ—Å–∏—Ç–µ') || line.toLowerCase().includes('—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ')) {
                        mainQuestion = line.trim();
                        break;
                    }
                }
            }
            
            // –ï—Å–ª–∏ –≤—Å—ë –µ—â—ë –Ω–µ—Ç –≤–æ–ø—Ä–æ—Å–∞, —Å–æ–∑–¥–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π
            if (!mainQuestion) {
                mainQuestion = '–°–æ–æ—Ç–Ω–µ—Å–∏—Ç–µ —ç–ª–µ–º–µ–Ω—Ç—ã:';
            }
            
            log(`    –û—Å–Ω–æ–≤–Ω–æ–π –≤–æ–ø—Ä–æ—Å: ${mainQuestion}`);
            log(`    –õ–µ–≤–∞—è —á–∞—Å—Ç—å (–±—É–∫–≤—ã): ${leftItems.length} —ç–ª–µ–º–µ–Ω—Ç–æ–≤`);
            log(`    –ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å (—Ü–∏—Ñ—Ä—ã): ${rightItems.length} —ç–ª–µ–º–µ–Ω—Ç–æ–≤`);
            
            if (leftItems.length === 0 || rightItems.length === 0) {
                log(`    ‚ö† –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è —Å–æ–æ—Ç–Ω–µ—Å–µ–Ω–∏—è`);
                return null;
            }
            
            // –ü–∞—Ä—Å–∏–º –æ—Ç–≤–µ—Ç
            const answerMap = parseMatchingAnswer(correctAnswerText);
            
            log(`    –û—Ç–≤–µ—Ç —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω: ${JSON.stringify(answerMap)}`);
            
            if (Object.keys(answerMap).length === 0) {
                log(`    ‚ö† –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –æ—Ç–≤–µ—Ç`);
                return null;
            }
            
            return {
                id: Date.now() + Math.random(),
                type: 'matching',
                question: mainQuestion,
                leftItems,  // –±—É–∫–≤—ã –ê, –ë, –í
                rightItems, // —Ü–∏—Ñ—Ä—ã 1, 2, 3
                correctAnswer: answerMap,
                raw: cellData.map(c => c.text).join(' | ')
            };
        }
        
        // –ü–∞—Ä—Å–∏–Ω–≥ –æ—Ç–≤–µ—Ç–∞ –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è: "1) –ê 2) –ë 3) –í" –∏–ª–∏ "1-–ê, 2-–ë"
        function parseMatchingAnswer(text) {
            const map = {};
            const cleanText = text.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
            
            log(`    –ü–∞—Ä—Å–∏–Ω–≥ –æ—Ç–≤–µ—Ç–∞: "${cleanText}"`);
            
            // –§–æ—Ä–º–∞—Ç: 1) –ê –∏–ª–∏ 1)–ê –∏–ª–∏ 1-–ê –∏–ª–∏ 1 - –ê
            const pattern1 = /(\d+)\s*[\)\-‚Äì‚Äî]\s*([–ê-–ØA-Z–∞-—èa-z])/g;
            let match;
            while ((match = pattern1.exec(cleanText)) !== null) {
                let letter = match[2].toUpperCase();
                // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ª–∞—Ç–∏–Ω–∏—Ü—É –≤ –∫–∏—Ä–∏–ª–ª–∏—Ü—É
                const keyMap = {'A': '–ê', 'B': '–ë', 'C': '–í', 'D': '–ì', 'E': '–î', 'F': '–ï'};
                letter = keyMap[letter] || letter;
                map[match[1]] = letter;
                log(`      –ù–∞–π–¥–µ–Ω–æ: ${match[1]} -> ${letter}`);
            }
            
            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –ø—Ä–æ–±—É–µ–º —Ñ–æ—Ä–º–∞—Ç –ê-1 –∏–ª–∏ –ê) 1
            if (Object.keys(map).length === 0) {
                const pattern2 = /([–ê-–ØA-Z–∞-—èa-z])\s*[\)\-‚Äì‚Äî]\s*(\d+)/g;
                while ((match = pattern2.exec(cleanText)) !== null) {
                    let letter = match[1].toUpperCase();
                    const keyMap = {'A': '–ê', 'B': '–ë', 'C': '–í', 'D': '–ì', 'E': '–î', 'F': '–ï'};
                    letter = keyMap[letter] || letter;
                    map[match[2]] = letter;
                    log(`      –ù–∞–π–¥–µ–Ω–æ (–æ–±—Ä–∞—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç): ${match[2]} -> ${letter}`);
                }
            }
            
            return map;
        }
        
        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –±—É–∫–≤–µ–Ω–Ω–æ–≥–æ –∫–ª—é—á–∞
        function normalizeLetterKey(key) {
            const upper = key.toUpperCase();
            const latinToCyrillic = {
                'A': '–ê', 'B': '–ë', 'C': '–í', 'D': '–ì', 'E': '–î', 
                'F': '–ï', 'G': '–ñ', 'H': '–ó', 'I': '–ò', 'J': '–ö'
            };
            return latinToCyrillic[upper] || upper;
        }
        
        // –ü–∞—Ä—Å–∏–Ω–≥ 5+ —Å—Ç–æ–ª–±—Ü–æ–≤
        function parseRow5Columns(cellData) {
            // –§–æ—Ä–º–∞—Ç: –Ω–æ–º–µ—Ä | –≤–æ–ø—Ä–æ—Å | –æ—Ç–≤–µ—Ç | —Ü–∏—Ñ—Ä—ã | –±—É–∫–≤—ã
            const col1 = cellData[0].text; // –Ω–æ–º–µ—Ä
            const col2 = cellData[1].text; // –≤–æ–ø—Ä–æ—Å
            const col3 = cellData[2].text; // –æ—Ç–≤–µ—Ç
            const col4 = cellData[3].text; // –≥—Ä—É–ø–ø–∞ 1
            const col5 = cellData[4] ? cellData[4].text : ''; // –≥—Ä—É–ø–ø–∞ 2
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
            if (isMatchingAnswer(col3)) {
                return parseMatching5Cols(col2, col3, col4, col5);
            }
            
            // –ò–Ω–∞—á–µ –ø—Ä–æ–±—É–µ–º –∫–∞–∫ –ø—Ä–æ—Å—Ç–æ–π –≤–æ–ø—Ä–æ—Å
            if (hasSimpleOptions(col2)) {
                return parseSimpleQuestion(col2, col3);
            }
            
            return parseFreeQuestion(col2, col3);
        }
        
        function parseMatching5Cols(questionText, answerText, col4, col5) {
            const leftItems = [];
            const rightItems = [];
            
            const numberPattern = /^([1-9])\s*[\)\.\:]\s*(.+)/;
            const letterPattern = /^([–ê–ë–í–ì–î–ï–ñ–ó–ò–ö–∞–±–≤–≥–¥–µ–∂–∑–∏–∫ABCDEFGHIJabcdefghij])\s*[\)\.\:]\s*(.+)/i;
            
            // –ü–∞—Ä—Å–∏–º col4 (–æ–±—ã—á–Ω–æ —Ü–∏—Ñ—Ä—ã)
            const lines4 = col4.split('\n').map(l => l.trim()).filter(l => l);
            for (const line of lines4) {
                const numMatch = line.match(numberPattern);
                const letMatch = line.match(letterPattern);
                
                if (numMatch) {
                    leftItems.push({ key: numMatch[1], text: numMatch[2].trim() });
                } else if (letMatch) {
                    const key = normalizeLetterKey(letMatch[1]);
                    rightItems.push({ key, text: letMatch[2].trim() });
                }
            }
            
            // –ü–∞—Ä—Å–∏–º col5 (–æ–±—ã—á–Ω–æ –±—É–∫–≤—ã)
            const lines5 = col5.split('\n').map(l => l.trim()).filter(l => l);
            for (const line of lines5) {
                const numMatch = line.match(numberPattern);
                const letMatch = line.match(letterPattern);
                
                if (numMatch) {
                    leftItems.push({ key: numMatch[1], text: numMatch[2].trim() });
                } else if (letMatch) {
                    const key = normalizeLetterKey(letMatch[1]);
                    rightItems.push({ key, text: letMatch[2].trim() });
                }
            }
            
            const answerMap = extractAnswerMapping(answerText, Math.max(leftItems.length, rightItems.length));
            
            log(`    Matching 5cols: left=${leftItems.length}, right=${rightItems.length}, answers=${JSON.stringify(answerMap)}`);
            
            if (leftItems.length >= 1 && rightItems.length >= 1 && Object.keys(answerMap).length >= 1) {
                return {
                    id: Date.now() + Math.random(),
                    type: 'matching',
                    question: questionText.split('\n')[0].trim() || '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ:',
                    leftItems,
                    rightItems,
                    correctAnswer: answerMap,
                    raw: `${questionText} | ${answerText} | ${col4} | ${col5}`
                };
            }
            
            return null;
        }

        // ===== –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –≤–æ–ø—Ä–æ—Å–∞ =====
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
        function isMatchingQuestion(col2Text, col3Text, col4Text) {
            // –í–∞—Ä–∏–∞–Ω—Ç 1: –≤ col2 –±—É–∫–≤—ã –ê)–ë)–í), –≤ col3 —Ü–∏—Ñ—Ä—ã –∏–ª–∏ —Ç–µ–∫—Å—Ç
            const hasLettersInCol2 = /[–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEabcde]\s*[\)\.\:]/.test(col2Text);
            // –í–∞—Ä–∏–∞–Ω—Ç 2: –≤ col2 —Ü–∏—Ñ—Ä—ã 1)2)3), –≤ col3 –±—É–∫–≤—ã –ê)–ë)–í)
            const hasNumbersInCol2 = /[1-9]\s*[\)\.\:]/.test(col2Text);
            const hasLettersInCol3 = /[–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEabcde]\s*[\)\.\:]/.test(col3Text);
            
            // –ö–æ–Ω—Ç–µ–Ω—Ç –≤ –æ–±–µ–∏—Ö –∫–æ–ª–æ–Ω–∫–∞—Ö
            const lines2 = col2Text.split('\n').filter(l => l.trim().length > 2);
            const lines3 = col3Text.split('\n').filter(l => l.trim().length > 2);
            const hasBothContent = lines2.length >= 2 && lines3.length >= 1;
            
            // –û—Ç–≤–µ—Ç –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∞–ø–ø–∏–Ω–≥ —Ç–∏–ø–∞ 1-–ê, 2-–ë, 1)–ê, –ê-1 –∏ —Ç.–¥.
            const hasMapping = /[1-9]\s*[-‚Äì‚Äî)\s]*[–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEabcde]|[–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEabcde]\s*[-‚Äì‚Äî)\s]*[1-9]/i.test(col4Text);
            
            const isMatch = ((hasLettersInCol2 || hasNumbersInCol2) && hasBothContent && hasMapping) ||
                           (hasNumbersInCol2 && hasLettersInCol3 && hasMapping);
            
            log(`    isMatching: lettersCol2=${hasLettersInCol2}, numsCol2=${hasNumbersInCol2}, lettersCol3=${hasLettersInCol3}, bothContent=${hasBothContent}, mapping=${hasMapping}, result=${isMatch}`);
            
            return isMatch;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–æ—Å—Ç–æ–π –≤–æ–ø—Ä–æ—Å —Å –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏
        function hasSimpleOptions(text) {
            // –ò—â–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Ç–∏–ø–∞ "1) —Ç–µ–∫—Å—Ç" –∏–ª–∏ "–ê) —Ç–µ–∫—Å—Ç"
            const lines = text.split('\n');
            let optionCount = 0;
            
            for (const line of lines) {
                if (/^[ABCDEabcde–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µ1-5]\s*[\)\.\:]\s*.+/.test(line.trim())) {
                    optionCount++;
                }
            }
            
            return optionCount >= 2;
        }

        // ===== 4 —Å—Ç–æ–ª–±—Ü–∞ =====
        function parseRow4Columns(cellData) {
            const col1 = cellData[0].text; // –Ω–æ–º–µ—Ä
            const col2 = cellData[1].text; // –≤–æ–ø—Ä–æ—Å + –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏–ª–∏ –ª–µ–≤–∞—è —á–∞—Å—Ç—å —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è
            const col3 = cellData[2].text; // –ø—Ä–∞–≤–∞—è —á–∞—Å—Ç—å —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –∏–ª–∏ –ø—É—Å—Ç–æ
            const col4 = cellData[3].text; // –æ—Ç–≤–µ—Ç

            log(`    Col2: "${col2.substring(0, 50)}..."`);
            log(`    Col3: "${col3.substring(0, 50)}..."`);
            log(`    Col4: "${col4}"`);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
            if (isMatchingQuestion(col2, col3, col4)) {
                return parseMatchingQuestion(col2, col3, col4);
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –ø—Ä–æ—Å—Ç–æ–π –≤–æ–ø—Ä–æ—Å
            if (hasSimpleOptions(col2)) {
                return parseSimpleQuestion(col2, col4 || col3);
            }

            // –°–≤–æ–±–æ–¥–Ω—ã–π –æ—Ç–≤–µ—Ç
            if (col2.length > 10 && (col3.length > 3 || col4.length > 3)) {
                return parseFreeQuestion(col2, col4 || col3);
            }

            return null;
        }

        // ===== 3 —Å—Ç–æ–ª–±—Ü–∞: –Ω–æ–º–µ—Ä | –≤–æ–ø—Ä–æ—Å | –æ—Ç–≤–µ—Ç =====
        function parseRow3Columns(cellData) {
            const col1 = cellData[0].text;
            const col2 = cellData[1].text;
            const col3 = cellData[2].text;

            log(`    Col2: "${col2.substring(0, 50)}..."`);
            log(`    Col3: "${col3}"`);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ (–æ—Ç–≤–µ—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –º–∞–ø–ø–∏–Ω–≥ 1)–ê 2)–ë)
            if (isMatchingAnswer(col3) && hasMatchingOptions(col2)) {
                return parseMatchingFromSingleColumn(col2, col3);
            }

            // –ü—Ä–æ—Å—Ç–æ–π –≤–æ–ø—Ä–æ—Å
            if (hasSimpleOptions(col2)) {
                return parseSimpleQuestion(col2, col3);
            }

            // –°–≤–æ–±–æ–¥–Ω—ã–π –æ—Ç–≤–µ—Ç
            if (col2.length > 10 && col3.length > 0) {
                return parseFreeQuestion(col2, col3);
            }

            return null;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –æ—Ç–≤–µ—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –º–∞–ø–ø–∏–Ω–≥ –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è
        function isMatchingAnswer(text) {
            // –ò—â–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã: 1)–ê, 1-–ê, 1) –ê, –ê-1 –∏ —Ç.–¥. (–º–∏–Ω–∏–º—É–º 2 –ø–∞—Ä—ã)
            const pattern1 = /[1-9]\s*[\)\-‚Äì‚Äî]\s*[–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEFabcdef]/g;
            const pattern2 = /[–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEFabcdef]\s*[\)\-‚Äì‚Äî]\s*[1-9]/g;
            
            const matches1 = text.match(pattern1) || [];
            const matches2 = text.match(pattern2) || [];
            
            const result = matches1.length >= 2 || matches2.length >= 2;
            log(`    isMatchingAnswer: "${text}" -> ${result} (found ${matches1.length + matches2.length} pairs)`);
            return result;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ —Ç–µ–∫—Å—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è (–∏ —Ü–∏—Ñ—Ä—ã, –∏ –±—É–∫–≤—ã)
        function hasMatchingOptions(text) {
            const hasNumbers = /[1-9]\s*[\)\.\:]/.test(text);
            const hasLetters = /[–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEFabcdef]\s*[\)\.\:]/.test(text);
            const result = hasNumbers && hasLetters;
            log(`    hasMatchingOptions: nums=${hasNumbers}, letters=${hasLetters} -> ${result}`);
            return result;
        }
        
        // –ü–∞—Ä—Å–∏–Ω–≥ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –∏–∑ –æ–¥–Ω–æ–π –∫–æ–ª–æ–Ω–∫–∏ (–≤—Å—ë –≤ col2)
        function parseMatchingFromSingleColumn(text, answerText) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            
            let questionTitle = '';
            const leftItems = [];  // –¶–∏—Ñ—Ä—ã (1, 2, 3)
            const rightItems = []; // –ë—É–∫–≤—ã (–ê, –ë, –í)
            
            const numberPattern = /^([1-9])\s*[\)\.\:]\s*(.+)/;
            const letterPattern = /^([–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEFabcdef])\s*[\)\.\:]\s*(.+)/i;
            
            for (const line of lines) {
                const numMatch = line.match(numberPattern);
                const letMatch = line.match(letterPattern);
                
                if (numMatch) {
                    leftItems.push({
                        key: numMatch[1],
                        text: numMatch[2].trim()
                    });
                } else if (letMatch) {
                    const key = letMatch[1].toUpperCase();
                    const normalizedKey = {'A':'–ê','B':'–ë','C':'–í','D':'–ì','E':'–î','F':'–ï'}[key] || key;
                    rightItems.push({
                        key: normalizedKey,
                        text: letMatch[2].trim()
                    });
                } else if (line.length > 3 && leftItems.length === 0 && rightItems.length === 0) {
                    questionTitle += (questionTitle ? ' ' : '') + line;
                }
            }
            
            // –ü–∞—Ä—Å–∏–º –æ—Ç–≤–µ—Ç
            const answerMap = extractAnswerMapping(answerText, Math.max(leftItems.length, rightItems.length));
            
            log(`    Matching from single col: left=${leftItems.length}, right=${rightItems.length}, answers=${JSON.stringify(answerMap)}`);
            
            if (leftItems.length >= 2 && rightItems.length >= 2 && Object.keys(answerMap).length >= 2) {
                return {
                    id: Date.now() + Math.random(),
                    type: 'matching',
                    question: questionTitle || '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ:',
                    leftItems,
                    rightItems,
                    correctAnswer: answerMap,
                    raw: `${text} | ${answerText}`
                };
            }
            
            return null;
        }

        // ===== 2 —Å—Ç–æ–ª–±—Ü–∞ =====
        function parseRow2Columns(cellData) {
            const col1 = cellData[0].text;
            const col2 = cellData[1].text;

            // –ü—Ä–æ—Å—Ç–æ–π –≤–æ–ø—Ä–æ—Å (–æ—Ç–≤–µ—Ç –≤–Ω—É—Ç—Ä–∏ —Ç–µ–∫—Å—Ç–∞ –∏–ª–∏ –≤ –∫–æ–Ω—Ü–µ)
            if (hasSimpleOptions(col2)) {
                return parseSimpleQuestion(col2, null);
            }

            return null;
        }

        // ==================== –ü–ê–†–°–ò–ù–ì –°–û–ü–û–°–¢–ê–í–õ–ï–ù–ò–Ø ====================
        
        function parseMatchingQuestion(col2Text, col3Text, col4Text) {
            const lines2 = col2Text.split('\n').map(l => l.trim()).filter(l => l);
            const lines3 = col3Text.split('\n').map(l => l.trim()).filter(l => l);

            let questionTitle = '';
            const leftItems = [];  // –ë—É–¥—É—Ç —Ü–∏—Ñ—Ä—ã (1, 2, 3)
            const rightItems = []; // –ë—É–¥—É—Ç –±—É–∫–≤—ã (–ê, –ë, –í)

            // –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –ê) –ë) –í)
            const letterPattern = /^([–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEFabcdef])\s*[\)\.\:]\s*(.+)/;
            // –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è 1) 2) 3)
            const numberPattern = /^([1-9])\s*[\)\.\:]\s*(.+)/;

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —á—Ç–æ –≤ col2: —Ü–∏—Ñ—Ä—ã –∏–ª–∏ –±—É–∫–≤—ã
            const hasNumbersInCol2 = lines2.some(l => numberPattern.test(l));
            const hasLettersInCol2 = lines2.some(l => letterPattern.test(l));
            const hasLettersInCol3 = lines3.some(l => letterPattern.test(l));

            log(`    Matching structure: numsCol2=${hasNumbersInCol2}, lettersCol2=${hasLettersInCol2}, lettersCol3=${hasLettersInCol3}`);

            if (hasNumbersInCol2 && hasLettersInCol3) {
                // –§–æ—Ä–º–∞—Ç: col2 = —Ü–∏—Ñ—Ä—ã (1, 2), col3 = –±—É–∫–≤—ã (–ê, –ë)
                for (const line of lines2) {
                    const match = line.match(numberPattern);
                    if (match) {
                        leftItems.push({
                            key: match[1],
                            text: match[2].trim()
                        });
                    } else if (line.length > 3 && leftItems.length === 0) {
                        questionTitle += (questionTitle ? ' ' : '') + line;
                    }
                }
                
                for (const line of lines3) {
                    const match = line.match(letterPattern);
                    if (match) {
                        const key = match[1].toUpperCase();
                        const normalizedKey = {'A':'–ê','B':'–ë','C':'–í','D':'–ì','E':'–î','F':'–ï'}[key] || key;
                        rightItems.push({
                            key: normalizedKey,
                            text: match[2].trim()
                        });
                    }
                }
            } else if (hasLettersInCol2) {
                // –§–æ—Ä–º–∞—Ç: col2 = –±—É–∫–≤—ã (–ê, –ë), col3 = —Ü–∏—Ñ—Ä—ã –∏–ª–∏ —Ç–µ–∫—Å—Ç
                for (const line of lines2) {
                    const match = line.match(letterPattern);
                    if (match) {
                        const key = match[1].toUpperCase();
                        const normalizedKey = {'A':'–ê','B':'–ë','C':'–í','D':'–ì','E':'–î','F':'–ï'}[key] || key;
                        rightItems.push({
                            key: normalizedKey,
                            text: match[2].trim()
                        });
                    } else if (line.length > 3 && rightItems.length === 0) {
                        questionTitle += (questionTitle ? ' ' : '') + line;
                    }
                }
                
                let autoNumber = 1;
                for (const line of lines3) {
                    const match = line.match(numberPattern);
                    if (match) {
                        leftItems.push({
                            key: match[1],
                            text: match[2].trim()
                        });
                    } else if (line.length > 2) {
                        leftItems.push({
                            key: String(autoNumber++),
                            text: line
                        });
                    }
                }
            } else if (hasNumbersInCol2) {
                // –¢–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã –≤ col2, —Ç–µ–∫—Å—Ç –≤ col3
                for (const line of lines2) {
                    const match = line.match(numberPattern);
                    if (match) {
                        leftItems.push({
                            key: match[1],
                            text: match[2].trim()
                        });
                    } else if (line.length > 3 && leftItems.length === 0) {
                        questionTitle += (questionTitle ? ' ' : '') + line;
                    }
                }
                
                // –ê–≤—Ç–æ–Ω—É–º–µ—Ä–∞—Ü–∏—è –±—É–∫–≤–∞–º–∏ –¥–ª—è –ø—Ä–∞–≤–æ–π —á–∞—Å—Ç–∏
                const letters = ['–ê', '–ë', '–í', '–ì', '–î', '–ï'];
                let letterIdx = 0;
                for (const line of lines3) {
                    if (line.length > 2) {
                        rightItems.push({
                            key: letters[letterIdx++] || String(letterIdx),
                            text: line
                        });
                    }
                }
            }

            // –ü–∞—Ä—Å–∏–º –æ—Ç–≤–µ—Ç
            const answerMap = extractAnswerMapping(col4Text, Math.max(leftItems.length, rightItems.length));

            log(`    Matching parsed: left=${leftItems.length} [${leftItems.map(i=>i.key).join(',')}], right=${rightItems.length} [${rightItems.map(i=>i.key).join(',')}], answers=${JSON.stringify(answerMap)}`);

            if (leftItems.length >= 2 && rightItems.length >= 1 && Object.keys(answerMap).length >= 1) {
                return {
                    id: Date.now() + Math.random(),
                    type: 'matching',
                    question: questionTitle || '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ:',
                    leftItems,
                    rightItems,
                    correctAnswer: answerMap,
                    raw: `${col2Text} | ${col3Text} | ${col4Text}`
                };
            }

            return null;
        }

        function extractAnswerMapping(text, expectedCount) {
            const map = {};
            
            // –£–±–∏—Ä–∞–µ–º –ø–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
            const cleanText = text.replace(/\n/g, ' ').replace(/\s+/g, ' ');
            
            log(`    Parsing answer: "${cleanText}"`);

            // –§–æ—Ä–º–∞—Ç: 1-–ê, 1)–ê, 1) –ê, 1‚Äì–ê, 1‚Äî–ê
            let regex = /([1-9])\s*[-‚Äì‚Äî\)\.\:]\s*([–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEFabcdef])/g;
            let match;
            while ((match = regex.exec(cleanText)) !== null) {
                const key = match[2].toUpperCase();
                const normalizedKey = {'A':'–ê','B':'–ë','C':'–í','D':'–ì','E':'–î','F':'–ï'}[key] || key;
                map[match[1]] = normalizedKey;
            }

            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –ø—Ä–æ–±—É–µ–º —Ñ–æ—Ä–º–∞—Ç –ê-1
            if (Object.keys(map).length === 0) {
                regex = /([–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEFabcdef])\s*[-‚Äì‚Äî\)\.\:]\s*([1-9])/g;
                while ((match = regex.exec(cleanText)) !== null) {
                    const key = match[1].toUpperCase();
                    const normalizedKey = {'A':'–ê','B':'–ë','C':'–í','D':'–ì','E':'–î','F':'–ï'}[key] || key;
                    map[match[2]] = normalizedKey;
                }
            }

            // Fallback: –ø—Ä–æ—Å—Ç–æ –±—É–∫–≤—ã –ø–æ –ø–æ—Ä—è–¥–∫—É (–ê –ë –í –∏–ª–∏ –ê–ë–í)
            if (Object.keys(map).length === 0) {
                const letters = cleanText.match(/[–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEFabcdef]/g);
                if (letters && letters.length >= 2) {
                    letters.forEach((l, i) => {
                        const key = l.toUpperCase();
                        const normalizedKey = {'A':'–ê','B':'–ë','C':'–í','D':'–ì','E':'–î','F':'–ï'}[key] || key;
                        map[String(i + 1)] = normalizedKey;
                    });
                }
            }

            log(`    Answer map: ${JSON.stringify(map)}`);
            return map;
        }

        // ==================== –ü–ê–†–°–ò–ù–ì –ü–†–û–°–¢–û–ì–û –í–û–ü–†–û–°–ê ====================
        
        function parseSimpleQuestion(text, answerFromCell) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);

            let questionText = '';
            const options = [];
            let correctAnswer = '';

            // –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –æ—Ç–≤–µ—Ç–∞
            // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç: A) B) C) D) E) –∏–ª–∏ –ê) –ë) –í) –ì) –î) –∏–ª–∏ 1) 2) 3) 4) 5)
            const optionPattern = /^([ABCDEabcde–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µ1-5])\s*[\)\.\:]\s*(.+)/;
            
            let foundOptions = false;

            for (const line of lines) {
                const match = line.match(optionPattern);
                
                if (match) {
                    foundOptions = true;
                    let key = match[1].toUpperCase();
                    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ª–∞—Ç–∏–Ω–∏—Ü—É –≤ –∫–∏—Ä–∏–ª–ª–∏—Ü—É –¥–ª—è –±—É–∫–≤ A-E
                    if (/[A-E]/.test(key)) {
                        key = {'A':'–ê','B':'–ë','C':'–í','D':'–ì','E':'–î'}[key] || key;
                    }
                    options.push({
                        key: key,
                        text: match[2].trim()
                    });
                } else if (!foundOptions && line.length > 2) {
                    // –≠—Ç–æ —á–∞—Å—Ç—å –≤–æ–ø—Ä–æ—Å–∞
                    questionText += (questionText ? ' ' : '') + line;
                } else if (foundOptions && /^[ABCDE–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µ1-5]$/i.test(line)) {
                    // –≠—Ç–æ –æ—Ç–≤–µ—Ç –≤ –∫–æ–Ω—Ü–µ —Ç–µ–∫—Å—Ç–∞
                    correctAnswer = normalizeAnswerKey(line.toUpperCase());
                }
            }

            // –ë–µ—Ä—ë–º –æ—Ç–≤–µ—Ç –∏–∑ –æ—Ç–¥–µ–ª—å–Ω–æ–π —è—á–µ–π–∫–∏
            if (!correctAnswer && answerFromCell) {
                const cleaned = answerFromCell.trim();
                // –ò—â–µ–º –ø–µ—Ä–≤—ã–π –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Å–∏–º–≤–æ–ª (–±—É–∫–≤—É –∏–ª–∏ —Ü–∏—Ñ—Ä—É)
                const answerMatch = cleaned.match(/^([ABCDE–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µ1-5])/i);
                if (answerMatch) {
                    correctAnswer = normalizeAnswerKey(answerMatch[1].toUpperCase());
                }
            }

            log(`    Simple parse: q="${questionText.substring(0, 40)}...", opts=${options.length}, keys=[${options.map(o=>o.key).join(',')}], ans="${correctAnswer}"`);

            // –í–∞–ª–∏–¥–∞—Ü–∏—è
            if (questionText && options.length >= 2 && correctAnswer) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –æ—Ç–≤–µ—Ç –µ—Å—Ç—å —Å—Ä–µ–¥–∏ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
                const optionKeys = options.map(o => o.key);
                if (optionKeys.includes(correctAnswer)) {
                    return {
                        id: Date.now() + Math.random(),
                        type: 'simple',
                        question: questionText,
                        options,
                        correctAnswer,
                        raw: text
                    };
                } else {
                    log(`    ‚ö†Ô∏è Answer "${correctAnswer}" not in options [${optionKeys.join(',')}]`);
                }
            }

            return null;
        }

        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª—é—á–∞ –æ—Ç–≤–µ—Ç–∞
        function normalizeAnswerKey(key) {
            // –õ–∞—Ç–∏–Ω–∏—Ü–∞ -> –∫–∏—Ä–∏–ª–ª–∏—Ü–∞
            const latinToCyrillic = {'A':'–ê','B':'–ë','C':'–í','D':'–ì','E':'–î'};
            return latinToCyrillic[key] || key;
        }

        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª—é—á–µ–π (–ª–∞—Ç–∏–Ω–∏—Ü–∞ -> –∫–∏—Ä–∏–ª–ª–∏—Ü–∞ –≥–¥–µ –Ω—É–∂–Ω–æ)
        function normalizeKey(key) {
            const map = { 'A': '–ê', 'B': '–ë', 'C': '–í', 'D': '–ì', 'E': '–î' };
            return map[key] || key;
        }

        // ==================== –ü–ê–†–°–ò–ù–ì –°–í–û–ë–û–î–ù–û–ì–û –û–¢–í–ï–¢–ê ====================
        
        function parseFreeQuestion(questionText, answerText) {
            const question = questionText.replace(/<[^>]+>/g, '').trim();
            const answer = (answerText || '').replace(/<[^>]+>/g, '').trim();

            log(`    Free parse: q="${question.substring(0, 40)}...", ans="${answer.substring(0, 30)}..."`);

            if (question.length > 5 && answer.length > 0) {
                return {
                    id: Date.now() + Math.random(),
                    type: 'free',
                    question,
                    correctAnswer: answer,
                    raw: `${question} | ${answer}`
                };
            }
            return null;
        }

        // ==================== UI –ü–ê–†–°–ï–†–ê ====================

        function displayParsePreview() {
            const status = document.getElementById('parseStatus');
            const preview = document.getElementById('parsePreview');
            const content = document.getElementById('previewContent');

            if (parsedQuestions.length === 0) {
                status.innerHTML = '<span class="text-yellow-500">‚ö†Ô∏è –í–æ–ø—Ä–æ—Å—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞.</span>';
                return;
            }

            const simple = parsedQuestions.filter(q => q.type === 'simple').length;
            const matching = parsedQuestions.filter(q => q.type === 'matching').length;
            const free = parsedQuestions.filter(q => q.type === 'free').length;

            status.innerHTML = `<span class="text-green-500">‚úÖ –ù–∞–π–¥–µ–Ω–æ ${parsedQuestions.length} –≤–æ–ø—Ä–æ—Å–æ–≤ (–ø—Ä–æ—Å—Ç—ã—Ö: ${simple}, —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ: ${matching}, —Å–≤–æ–±–æ–¥–Ω—ã—Ö: ${free})</span>`;
            preview.classList.remove('hidden');

            content.innerHTML = parsedQuestions.map((q, i) => `
                <div class="border-b pb-2 mb-2">
                    <div class="flex justify-between items-start">
                        <span class="font-bold text-sm px-2 py-1 rounded ${
                            q.type === 'simple' ? 'bg-blue-100 text-blue-800' : 
                            q.type === 'matching' ? 'bg-purple-100 text-purple-800' : 
                            'bg-green-100 text-green-800'
                        }">${i + 1}. ${q.type === 'simple' ? '–ü—Ä–æ—Å—Ç–æ–π' : q.type === 'matching' ? '–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ' : '–°–≤–æ–±–æ–¥–Ω—ã–π'}</span>
                        <button onclick="removeParsedQuestion(${i})" class="text-red-500 hover:text-red-700 ml-2">‚úñÔ∏è</button>
                    </div>
                    <p class="text-sm mt-1">${escapeHtml(q.question.substring(0, 100))}${q.question.length > 100 ? '...' : ''}</p>
                    <p class="text-xs text-gray-500 mt-1">–û—Ç–≤–µ—Ç: ${q.type === 'matching' ? Object.entries(q.correctAnswer).map(([k,v]) => `${k}-${v}`).join(', ') : q.correctAnswer}</p>
                </div>
            `).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function removeParsedQuestion(index) {
            parsedQuestions.splice(index, 1);
            displayParsePreview();
        }

        function saveQuestions() {
            questions = [...questions, ...parsedQuestions];
            localStorage.setItem('testQuestions', JSON.stringify(questions));
            parsedQuestions = [];
            document.getElementById('parsePreview').classList.add('hidden');
            document.getElementById('debugArea').classList.add('hidden');
            document.getElementById('parseStatus').innerHTML = '<span class="text-green-500">‚úÖ –í–æ–ø—Ä–æ—Å—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!</span>';
            document.getElementById('fileInput').value = '';
        }

        // ==================== –°–ü–ò–°–û–ö –í–û–ü–†–û–°–û–í ====================

        function renderQuestionsList() {
            const list = document.getElementById('questionsList');
            const count = document.getElementById('questionCount');
            
            count.textContent = `${questions.length} –≤–æ–ø—Ä–æ—Å–æ–≤`;
            
            if (questions.length === 0) {
                list.innerHTML = '<p class="text-gray-500 text-center py-8">–ù–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤</p>';
                return;
            }

            list.innerHTML = questions.map((q, i) => `
                <div class="border rounded-lg p-4 bg-gray-50">
                    <div class="flex justify-between items-start gap-2">
                        <div class="flex-1">
                            <span class="inline-block px-2 py-1 text-xs rounded ${
                                q.type === 'simple' ? 'bg-blue-100 text-blue-800' : 
                                q.type === 'matching' ? 'bg-purple-100 text-purple-800' : 
                                'bg-green-100 text-green-800'
                            }">${q.type === 'simple' ? '–ü—Ä–æ—Å—Ç–æ–π' : q.type === 'matching' ? '–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ' : '–°–≤–æ–±–æ–¥–Ω—ã–π'}</span>
                            <p class="mt-2 font-medium">${escapeHtml(q.question)}</p>
                            <p class="text-sm text-gray-500 mt-1">–û—Ç–≤–µ—Ç: ${
                                q.type === 'simple' ? q.correctAnswer : 
                                q.type === 'matching' ? Object.entries(q.correctAnswer).map(([k,v]) => `${k}-${v}`).join(', ') :
                                q.correctAnswer.substring(0, 50) + (q.correctAnswer.length > 50 ? '...' : '')
                            }</p>
                        </div>
                        <button onclick="deleteQuestion(${i})" class="text-red-500 hover:text-red-700 p-1">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        function deleteQuestion(index) {
            if (confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å?')) {
                questions.splice(index, 1);
                localStorage.setItem('testQuestions', JSON.stringify(questions));
                renderQuestionsList();
            }
        }

        function clearAllQuestions() {
            if (confirm('–£–¥–∞–ª–∏—Ç—å –í–°–ï –≤–æ–ø—Ä–æ—Å—ã? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.')) {
                questions = [];
                localStorage.removeItem('testQuestions');
                renderQuestionsList();
            }
        }

        // ==================== –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï ====================

        function startTest() {
            const randomize = document.getElementById('randomize').checked;
            const randomizeAnswers = document.getElementById('randomizeAnswers').checked;
            const limit = parseInt(document.getElementById('questionLimit').value) || questions.length;
            const typeFilter = document.getElementById('typeFilter').value;

            let testQuestions = [...questions];
            
            if (typeFilter !== 'all') {
                testQuestions = testQuestions.filter(q => q.type === typeFilter);
            }

            if (testQuestions.length === 0) {
                alert('–ù–µ—Ç –≤–æ–ø—Ä–æ—Å–æ–≤ –¥–ª—è —Ç–µ—Å—Ç–∞!');
                return;
            }

            if (randomize) {
                testQuestions = shuffleArray(testQuestions);
            }

            currentTest = testQuestions.slice(0, limit).map(q => {
                if (randomizeAnswers && q.type === 'simple') {
                    return { ...q, options: shuffleArray([...q.options]) };
                }
                return { ...q };
            });

            currentIndex = 0;
            testAnswers = {};
            testMode = 'normal';

            document.getElementById('testSetup').classList.add('hidden');
            document.getElementById('testArea').classList.remove('hidden');
            document.getElementById('testResults').classList.add('hidden');
            
            renderQuestion();
        }

        function practiceErrors() {
            if (errors.length === 0) {
                alert('–ù–µ—Ç –æ—à–∏–±–æ–∫ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è!');
                return;
            }

            currentTest = shuffleArray([...errors]);
            currentIndex = 0;
            testAnswers = {};
            testMode = 'errors';

            showTab('test');
            document.getElementById('testSetup').classList.add('hidden');
            document.getElementById('testArea').classList.remove('hidden');
            document.getElementById('testResults').classList.add('hidden');
            
            renderQuestion();
        }

        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function renderQuestion() {
            const q = currentTest[currentIndex];
            const progress = document.getElementById('testProgress');
            const area = document.getElementById('questionArea');

            progress.textContent = `${currentIndex + 1} / ${currentTest.length}`;

            let html = `<div class="mb-4"><p class="text-lg font-medium">${escapeHtml(q.question)}</p></div>`;

            if (q.type === 'simple') {
                html += '<div class="space-y-2">';
                q.options.forEach((opt, i) => {
                    const checked = testAnswers[currentIndex] === opt.key ? 'checked' : '';
                    html += `
                        <label class="flex items-center gap-3 p-3 border rounded-lg cursor-pointer hover:bg-gray-50 transition">
                            <input type="radio" name="answer" value="${opt.key}" ${checked} onchange="testAnswers[${currentIndex}] = '${opt.key}'" class="w-5 h-5">
                            <span><strong>${opt.key})</strong> ${escapeHtml(opt.text)}</span>
                        </label>
                    `;
                });
                html += '</div>';
            } else if (q.type === 'matching') {
                html += renderMatchingTest(q);
            } else if (q.type === 'free') {
                const saved = testAnswers[currentIndex] || '';
                html += `
                    <textarea 
                        class="w-full border rounded-lg p-3 min-h-[100px]" 
                        placeholder="–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –æ—Ç–≤–µ—Ç..."
                        oninput="testAnswers[${currentIndex}] = this.value"
                    >${escapeHtml(saved)}</textarea>
                `;
            }

            area.innerHTML = html;

            document.getElementById('prevBtn').disabled = currentIndex === 0;
            document.getElementById('prevBtn').classList.toggle('opacity-50', currentIndex === 0);
            document.getElementById('checkBtn').disabled = false;
            document.getElementById('checkBtn').classList.remove('opacity-50');
        }

        function renderMatchingTest(q) {
            if (!testAnswers[currentIndex]) {
                testAnswers[currentIndex] = {};
            }
            
            let html = '<div class="space-y-6">';
            
            // –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è
            html += '<div class="bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm text-blue-800">';
            html += 'üìå –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∫–∞—Ä—Ç–æ—á–∫–∏ —Å –±—É–∫–≤–∞–º–∏ –∫ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º –ø—É–Ω–∫—Ç–∞–º —Å–ø—Ä–∞–≤–∞';
            html += '</div>';
            
            html += '<div class="grid md:grid-cols-2 gap-6">';
            
            // –õ–µ–≤–∞—è —á–∞—Å—Ç—å - –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º—ã–µ –∫–∞—Ä—Ç–æ—á–∫–∏
            html += '<div>';
            html += '<h3 class="font-semibold mb-3 text-gray-700">–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∫–∞—Ä—Ç–æ—á–∫–∏:</h3>';
            html += '<div class="space-y-2" id="dragSource">';
            
            q.leftItems.forEach(item => {
                const isUsed = Object.values(testAnswers[currentIndex]).includes(item.key);
                html += `
                    <div 
                        draggable="true" 
                        data-key="${item.key}"
                        ondragstart="handleDragStart(event, '${item.key}')"
                        ondragend="handleDragEnd(event)"
                        class="p-3 border-2 rounded-lg bg-white cursor-move hover:shadow-lg transition ${isUsed ? 'opacity-40' : 'border-blue-300'}"
                    >
                        <strong class="text-lg text-blue-600">${item.key})</strong> <span class="text-gray-700">${escapeHtml(item.text)}</span>
                    </div>
                `;
            });
            
            html += '</div>';
            html += '</div>';
            
            // –ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å - –∑–æ–Ω—ã –¥–ª—è –¥—Ä–æ–ø–∞
            html += '<div>';
            html += '<h3 class="font-semibold mb-3 text-gray-700">–ö —ç—Ç–∏–º –ø—É–Ω–∫—Ç–∞–º:</h3>';
            html += '<div class="space-y-2">';
            
            q.rightItems.forEach(item => {
                const currentMatch = testAnswers[currentIndex][item.key] || '';
                html += `
                    <div 
                        class="p-3 border-2 border-dashed rounded-lg bg-gray-50 min-h-[60px]"
                        ondragover="handleDragOver(event)"
                        ondragleave="handleDragLeave(event)"
                        ondrop="handleDrop(event, '${item.key}')"
                        data-target="${item.key}"
                    >
                        <div class="text-sm text-gray-600 mb-1"><strong>${item.key})</strong> ${escapeHtml(item.text)}</div>
                        <div class="mt-2 min-h-[30px] flex items-center justify-center" id="slot-${item.key}">
                            ${currentMatch ? `
                                <div class="inline-flex items-center gap-2 bg-green-100 text-green-800 px-3 py-1 rounded-full border border-green-300">
                                    <strong>${currentMatch}</strong>
                                    <button onclick="removeMatch('${item.key}')" class="text-red-500 hover:text-red-700 font-bold">‚úñ</button>
                                </div>
                            ` : '<span class="text-gray-400 text-sm">–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Å—é–¥–∞</span>'}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            html += '</div>';
            
            html += '</div>';
            html += '</div>';
            return html;
        }

        // Drag & Drop handlers
        let draggedKey = null;

        function handleDragStart(event, key) {
            draggedKey = key;
            event.target.classList.add('dragging');
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
        }

        function handleDragOver(event) {
            event.preventDefault();
            const target = event.currentTarget;
            target.classList.add('drag-over');
        }

        function handleDragLeave(event) {
            event.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(event, targetKey) {
            event.preventDefault();
            const target = event.currentTarget;
            target.classList.remove('drag-over');
            
            if (!draggedKey) return;
            
            // –£–±–∏—Ä–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é —Å–≤—è–∑—å –µ—Å–ª–∏ –±—ã–ª–∞
            Object.keys(testAnswers[currentIndex]).forEach(key => {
                if (testAnswers[currentIndex][key] === draggedKey) {
                    delete testAnswers[currentIndex][key];
                }
            });
            
            // –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é —Å–≤—è–∑—å
            testAnswers[currentIndex][targetKey] = draggedKey;
            draggedKey = null;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            renderQuestion();
        }

        function removeMatch(targetKey) {
            delete testAnswers[currentIndex][targetKey];
            renderQuestion();
        }

        function checkAnswer() {
            const q = currentTest[currentIndex];
            const area = document.getElementById('questionArea');
            let isCorrect = false;
            let feedback = '';

            if (q.type === 'simple') {
                const userAnswer = testAnswers[currentIndex];
                isCorrect = userAnswer === q.correctAnswer;
                feedback = isCorrect 
                    ? '<div class="mt-4 p-4 bg-green-100 text-green-800 rounded-lg">‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ!</div>'
                    : `<div class="mt-4 p-4 bg-red-100 text-red-800 rounded-lg">‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ. –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: <strong>${q.correctAnswer}</strong></div>`;
            } else if (q.type === 'matching') {
                const userAnswer = testAnswers[currentIndex] || {};
                isCorrect = true;
                let details = [];
                
                Object.entries(q.correctAnswer).forEach(([key, val]) => {
                    if (userAnswer[key] !== val) {
                        isCorrect = false;
                        details.push(`${key} ‚Üí ${val}`);
                    }
                });

                feedback = isCorrect 
                    ? '<div class="mt-4 p-4 bg-green-100 text-green-800 rounded-lg">‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ!</div>'
                    : `<div class="mt-4 p-4 bg-red-100 text-red-800 rounded-lg">‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ. –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è: ${details.join(', ')}</div>`;
            } else if (q.type === 'free') {
                const userAnswer = (testAnswers[currentIndex] || '').toLowerCase().trim();
                const correct = q.correctAnswer.toLowerCase().trim();
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
                const correctWords = correct.split(/[\s,\.]+/).filter(w => w.length > 3);
                const matchedWords = correctWords.filter(w => userAnswer.includes(w));
                isCorrect = matchedWords.length >= correctWords.length * 0.5;
                
                feedback = `<div class="mt-4 p-4 ${isCorrect ? 'bg-green-100 text-green-800' : 'bg-yellow-100 text-yellow-800'} rounded-lg">
                    ${isCorrect ? '‚úÖ –ü–æ—Ö–æ–∂–µ –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç!' : '‚ö†Ô∏è –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–≤–æ–π –æ—Ç–≤–µ—Ç'}
                    <br><strong>–≠—Ç–∞–ª–æ–Ω:</strong> ${escapeHtml(q.correctAnswer)}
                </div>`;
            }

            area.innerHTML += feedback;

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—à–∏–±–∫—É
            if (!isCorrect && testMode !== 'errors') {
                const existingError = errors.find(e => e.question === q.question);
                if (!existingError) {
                    errors.push(q);
                    localStorage.setItem('testErrors', JSON.stringify(errors));
                }
            } else if (isCorrect && testMode === 'errors') {
                errors = errors.filter(e => e.question !== q.question);
                localStorage.setItem('testErrors', JSON.stringify(errors));
            }

            document.getElementById('checkBtn').disabled = true;
            document.getElementById('checkBtn').classList.add('opacity-50');
        }

        function prevQuestion() {
            if (currentIndex > 0) {
                currentIndex--;
                renderQuestion();
            }
        }

        function nextQuestion() {
            if (currentIndex < currentTest.length - 1) {
                currentIndex++;
                renderQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            document.getElementById('testArea').classList.add('hidden');
            document.getElementById('testResults').classList.remove('hidden');

            let correct = 0;
            currentTest.forEach((q, i) => {
                const answer = testAnswers[i];
                if (q.type === 'simple' && answer === q.correctAnswer) correct++;
                else if (q.type === 'matching') {
                    let allMatch = true;
                    Object.entries(q.correctAnswer).forEach(([key, val]) => {
                        if (!answer || answer[key] !== val) allMatch = false;
                    });
                    if (allMatch) correct++;
                }
            });

            const percentage = Math.round((correct / currentTest.length) * 100);
            
            document.getElementById('resultsContent').innerHTML = `
                <div class="text-6xl mb-4">${percentage >= 70 ? 'üéâ' : percentage >= 50 ? 'üìö' : 'üí™'}</div>
                <p class="text-3xl font-bold ${percentage >= 70 ? 'text-green-500' : percentage >= 50 ? 'text-yellow-500' : 'text-red-500'}">${percentage}%</p>
                <p class="text-gray-600 mt-2">–ü—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤: ${correct} –∏–∑ ${currentTest.length}</p>
                ${errors.length > 0 ? `<p class="text-red-500 mt-2">–û—à–∏–±–æ–∫ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è: ${errors.length}</p>` : ''}
            `;
        }

        function endTest() {
            if (confirm('–ó–∞–≤–µ—Ä—à–∏—Ç—å —Ç–µ—Å—Ç?')) {
                document.getElementById('testArea').classList.add('hidden');
                document.getElementById('testSetup').classList.remove('hidden');
            }
        }

        // ==================== –û–®–ò–ë–ö–ò ====================

        function renderErrorsList() {
            const list = document.getElementById('errorsList');
            const count = document.getElementById('errorCount');
            
            count.textContent = `${errors.length} –æ—à–∏–±–æ–∫`;
            
            if (errors.length === 0) {
                list.innerHTML = '<p class="text-gray-500 text-center py-8">–ù–µ—Ç –æ—à–∏–±–æ–∫! –û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞! üéâ</p>';
                return;
            }

            list.innerHTML = errors.map((q, i) => `
                <div class="border rounded-lg p-4 bg-red-50">
                    <div class="flex justify-between items-start gap-2">
                        <div class="flex-1">
                            <p class="font-medium">${escapeHtml(q.question)}</p>
                            <p class="text-sm text-gray-600 mt-1">–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: 
                                ${q.type === 'simple' ? q.correctAnswer : 
                                  q.type === 'matching' ? Object.entries(q.correctAnswer).map(([k,v]) => `${k}-${v}`).join(', ') :
                                  escapeHtml(q.correctAnswer.substring(0, 50)) + '...'}
                            </p>
                        </div>
                        <button onclick="removeError(${i})" class="text-gray-500 hover:text-gray-700 p-1">‚úñÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        function removeError(index) {
            errors.splice(index, 1);
            localStorage.setItem('testErrors', JSON.stringify(errors));
            renderErrorsList();
        }

        function clearErrors() {
            if (confirm('–û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –æ—à–∏–±–∫–∏?')) {
                errors = [];
                localStorage.removeItem('testErrors');
                renderErrorsList();
            }
        }

        // ==================== –†–£–ß–ù–û–ï –î–û–ë–ê–í–õ–ï–ù–ò–ï ====================
        
        let lastRawHtml = '';
        
        function showRawHtml() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50';
            modal.innerHTML = `
                <div class="bg-white rounded-lg p-4 max-w-4xl w-full max-h-[80vh] overflow-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="font-bold">–°—ã—Ä–æ–π HTML –¥–æ–∫—É–º–µ–Ω—Ç–∞</h3>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                    </div>
                    <pre class="text-xs bg-gray-100 p-4 rounded overflow-auto max-h-[60vh] whitespace-pre-wrap">${escapeHtml(lastRawHtml)}</pre>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function toggleManualFields() {
            const type = document.getElementById('manualType').value;
            document.getElementById('simpleFields').classList.toggle('hidden', type !== 'simple');
            document.getElementById('matchingFields').classList.toggle('hidden', type !== 'matching');
            document.getElementById('freeFields').classList.toggle('hidden', type !== 'free');
        }
        
        function addManualQuestion() {
            const type = document.getElementById('manualType').value;
            const questionText = document.getElementById('manualQuestion').value.trim();
            
            if (!questionText) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –≤–æ–ø—Ä–æ—Å–∞!');
                return;
            }
            
            let question = null;
            
            if (type === 'simple') {
                const optionsText = document.getElementById('manualOptions').value.trim();
                const answer = document.getElementById('manualAnswer').value.trim().toUpperCase();
                
                const options = [];
                const optionPattern = /^([ABCDEabcde–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µ1-5])\s*[\)\.\:]\s*(.+)/;
                
                for (const line of optionsText.split('\n')) {
                    const match = line.trim().match(optionPattern);
                    if (match) {
                        let key = match[1].toUpperCase();
                        if (/[A-E]/.test(key)) {
                            key = {'A':'–ê','B':'–ë','C':'–í','D':'–ì','E':'–î'}[key] || key;
                        }
                        options.push({ key, text: match[2].trim() });
                    }
                }
                
                if (options.length < 2) {
                    alert('–î–æ–±–∞–≤—å—Ç–µ –º–∏–Ω–∏–º—É–º 2 –≤–∞—Ä–∏–∞–Ω—Ç–∞ –æ—Ç–≤–µ—Ç–∞!');
                    return;
                }
                
                const normalizedAnswer = {'A':'–ê','B':'–ë','C':'–í','D':'–ì','E':'–î'}[answer] || answer;
                
                question = {
                    id: Date.now() + Math.random(),
                    type: 'simple',
                    question: questionText,
                    options,
                    correctAnswer: normalizedAnswer
                };
                
            } else if (type === 'matching') {
                const leftText = document.getElementById('manualLeft').value.trim();
                const rightText = document.getElementById('manualRight').value.trim();
                const matchingText = document.getElementById('manualMatching').value.trim();
                
                const leftItems = [];
                const rightItems = [];
                
                const numberPattern = /^([1-9])\s*[\)\.\:]\s*(.+)/;
                const letterPattern = /^([–ê–ë–í–ì–î–ï–∞–±–≤–≥–¥–µABCDEFabcdef])\s*[\)\.\:]\s*(.+)/i;
                
                for (const line of leftText.split('\n')) {
                    const match = line.trim().match(numberPattern);
                    if (match) {
                        leftItems.push({ key: match[1], text: match[2].trim() });
                    }
                }
                
                for (const line of rightText.split('\n')) {
                    const match = line.trim().match(letterPattern);
                    if (match) {
                        const key = normalizeLetterKey(match[1]);
                        rightItems.push({ key, text: match[2].trim() });
                    }
                }
                
                if (leftItems.length < 1 || rightItems.length < 1) {
                    alert('–î–æ–±–∞–≤—å—Ç–µ –ø—É–Ω–∫—Ç—ã –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è!');
                    return;
                }
                
                const answerMap = extractAnswerMapping(matchingText, leftItems.length);
                
                if (Object.keys(answerMap).length < 1) {
                    alert('–£–∫–∞–∂–∏—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä: 1-–ê, 2-–ë)');
                    return;
                }
                
                question = {
                    id: Date.now() + Math.random(),
                    type: 'matching',
                    question: questionText,
                    leftItems,
                    rightItems,
                    correctAnswer: answerMap
                };
                
            } else if (type === 'free') {
                const answer = document.getElementById('manualFreeAnswer').value.trim();
                
                if (!answer) {
                    alert('–í–≤–µ–¥–∏—Ç–µ —ç—Ç–∞–ª–æ–Ω –æ—Ç–≤–µ—Ç–∞!');
                    return;
                }
                
                question = {
                    id: Date.now() + Math.random(),
                    type: 'free',
                    question: questionText,
                    correctAnswer: answer
                };
            }
            
            if (question) {
                questions.push(question);
                localStorage.setItem('testQuestions', JSON.stringify(questions));
                
                // –û—á–∏—â–∞–µ–º –ø–æ–ª—è
                document.getElementById('manualQuestion').value = '';
                document.getElementById('manualOptions').value = '';
                document.getElementById('manualAnswer').value = '';
                document.getElementById('manualLeft').value = '';
                document.getElementById('manualRight').value = '';
                document.getElementById('manualMatching').value = '';
                document.getElementById('manualFreeAnswer').value = '';
                
                alert('–í–æ–ø—Ä–æ—Å –¥–æ–±–∞–≤–ª–µ–Ω!');
            }
        }

        // –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º handleFileUpload —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω—è—Ç—å —Å—ã—Ä–æ–π HTML
        const originalHandleFileUpload = handleFileUpload;
        handleFileUpload = async function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const status = document.getElementById('parseStatus');
            status.classList.remove('hidden');
            status.innerHTML = '<span class="text-blue-500">‚è≥ –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞...</span>';
            debugLog = [];

            try {
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.convertToHtml({ arrayBuffer });
                lastRawHtml = result.value;
                log('HTML –ø–æ–ª—É—á–µ–Ω, –¥–ª–∏–Ω–∞', result.value.length);
                parseDocxContent(result.value);
                
                document.getElementById('debugArea').classList.remove('hidden');
                document.getElementById('debugContent').textContent = debugLog.join('\n');
            } catch (error) {
                status.innerHTML = `<span class="text-red-500">‚ùå –û—à–∏–±–∫–∞: ${error.message}</span>`;
            }
        };

        // Initialize
        showTab('parser');
    </script>
</body>
</html>
